多线程：

-- 进程：是程序的执行过程，是动态的，持有资源（内存，文件）和线程，双击运行一个程序既是一个进程

-- 线程：是系统中最小的执行单元，同一个进程有多个线程，多个线程共享进程的资源

线程的交互方式：

   --互斥：竞争，关键数据在同一时间只能有一个线程访问
   
   --同步：协作，线程间的一种通信控制，一个线程完成了某事后唤醒其他因某些资源不足而等待的线程
 
 
 
 线程的生命周期：

创建：创建一个Thread对象

就绪：创建了线程对象后，调用了线程的start()方法（注意：此时线程只是进入了线程队列，等待获取CPU服务，具备了运行的条件，但并不一定已经开始运行了）

运行：处于就绪状态的线程，一旦获取了CPU资源，便进入到运行状态，开始执行run()方法里面的逻辑

终止：线程的run()方法执行完毕，或者线程调用了stop()方法，线程便进入了终止状态。

阻塞：一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU，暂停自己的执行，便进入了阻塞状态。如调用sleep()、join()、wait()方法
 
 
 
 
 
 Race Condition <争用条件>
--当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupted）,这种现象称为争用条件。
   
   1,多线程之间的互斥（加锁实现）：同一时间，只能有一个线程访问临界区（防止线程之间争用条件造成的“能量损失”）[对该临界资源进行加锁，表示现在只能由该线程进行访问]
    
	    线程之间的互斥：通过加锁实现：线程访问临界区的代码放在一个代码块中，加锁实现
	 
   2,多线程之间的同步（线程的等待和唤醒：wait()+notifyAll()）：通信机制；一个线程完成，以某种方式通知其他线程可以访问临界区
        
		线程之间的同步：通过wait（）+notify（）的通信机制来实现
		
		线程同步的实现有wait()（会释放所资源和释放锁，然后进入锁对象上的wait set）,notify()（会唤醒所对象的wait set中的一个线程）,notifyall()（会唤醒所对象的wait set中的所有线程）这几个方法来实现,这几个方法都是属于object
   
   lockObj.notifyAll()；唤醒所有等待资源的线程。等待池的对象是不会竞争锁的，当notifyAll后，等待池中的线程会被唤醒进入到该线程的锁池中重新竞争对象锁，重新获得锁后的对象会从wait后继续执行代码，其他对象会被阻塞，而不是wait。被阻塞的对象会等待下一次被唤醒（notify、notifyAll）。另外，notify不是线程安全的，notifyAll才是。
   
   
--线程中的方法
   
Thread.currentThread().getName();获取当前线程的名称。

volatile;可见性，java的关键字(保证了线程可以正确的读取其他线程写入的值) 用于停止线程

Thread.yield();让出当前线程的执行权限，随机选择线程执行。

Thread.sleep();线程休眠

Thread.join();优先执行该线程，其他线程都暂停。使同级其他线程停下来，等待调用join方法的对象完成线程后，再进行其他线程

thread.isAlive()可以知道线程是否在运行，所以while死循环也可以做到”等待线程执行完，再执行下一行的代码的效果






--interrupt() 中止线程
 
  当一个线程调用因为调用sleep(),join(),方法被阻塞时。一旦其他线程调用 interrupt() 会使的中断状态被清除，并且抛出interruptedException 
  (被中断的线程会正常运行，所有不能与这些方法一起并用)
  
  --中断状态值：isInterrupted （默认为false，如果被阻塞则变为true）
  

  
  
  
  
 --并发编程的3个基本概念  
   
   -- 原子性： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
   
   -- 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
   
   -- 有序性：即程序执行的顺序按照代码的先后顺序执行。
   
   
   
   
   
 --守护线程：
  
 1、用户线程——运行在前台，执行具体的任务

        程序的主线程、连接网络的子线程等都是用户线程

2、守护线程——运行在后台，为其它线程服务

        特点：当所有的用户线程都结束运行，守护线程会随JVM一起结束工作

        应用：数据库连接池中的检测线程

                   JVM虚拟机启动后的监测线程 

        最常见的守护线程：垃圾回收线程

3、可以通过调用Thread类的setDaemon(true)方法，设置当前线程为守护线程。注意：

 a）该方法必须在start()方法之前调用，否则会抛出IllegalThreadStateException异常。

b）在守护线程中产生的新线程也是守护线程。

c）不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑。

