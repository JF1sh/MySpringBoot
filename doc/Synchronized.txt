Synchronized

 作用：能够保证在同一时刻最多只有一个线程执行该段代码，已达到保证并发安全的效果。
 
 
 
 
--用法：
   
    -- 对象锁: 1)代码块形式：手动锁定对象 (this 可以使用新建的对象来完成，)
	
	                        synchronized(this){
							   逻辑代码
							}

               2)方法锁形式：synchronized修饰普通方法，锁对象默认为this。在方法中加上 Synchronized关键字
			   
	
	--  类锁： 1) synchronized修饰静态方法:(一个类可以有多个实现类，但是只能有一个class对象。如果由多个实现类开起的线程，
	                                         同时去获取一个对象锁。所开启的线程都可以获取到，而使用类锁则只有一个可以获取到)。
											 
			 
  			  2) synchronized代码块(*.class)
	                        synchronized(*.class){
							   逻辑代码
							}
							
--方法抛出异常后，会释放锁。（自定义的clock不会自动释放）


-- 性质：  可重入：一旦一个线程获取到当前锁，可以一直用下去直到自己释放，别人才能获得。（当两个方法被一个锁修饰，当前线程可以执行完两个方法后再释放锁）

           不可中断： 一旦一把锁被别人获取，除非他释放不然我只能一直等待
		   
		   
		   
		   
		   
--synchronized关键字的缺陷

效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程

不够灵活（读写锁更灵活）：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的

无法知道是否成功获得到锁