实现多线程的方式：
   通常来说有两种。准确的来说，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式：
     1：实现Runnable接口的run方法 ，把Runnable实例传给Thread类
     2: 继承Thread类，重写run方法。


两个方法的比较：
   1：从代码架构的方面：把线程和任务解耦，所以用runnable
   2: 从新建线程的方面：新建一个任务必须新建一个线程，消耗资源，所以runnable好
   3: 从语言特性的方法：java不支持多继承， （单继承多实现）


start()方法调用过程:
   1: 首先判断threadStatus是否为0 ，如果不为0则新建的线程被调用了2次start()方法 会抛出IllegalThreadStateException
   2: 然后加入到ThreadGroup
   3：调用 native start0() 方法


如何停止线程:
   1)尽可能使用interrupt()来请求线程停止，让停止方自己判断自己在何时停止，安全
   2)想要停止线程，需要 请求方，停止方，子方法被调用方 多方配合。
        A)停止方：需要再循环或者适当的时候检查中断状态，并在可能出现InterruptedException异常的时候处理该中断线程；
        B)请求方：发出中断信息；
        C)子方法调用方 (被线程调用的方法): 优先在方法层抛出InterruptedException，或者在检查中断状态时再设置中断状态；
   3)volatile 的boolean 无法处理长时间阻塞的线程。



interrupt: 中断线程，线程中没有阻塞方法的情况下，会执行成功使线程中断。
判断线程是否中断的相关方法：
  static boolean interrupted():  获取当前线程是否被中断，在返回后会清除中断状态

  boolean isInterrupted(): 获取当前线程是否被中断，不清除状态。

  Thread.interrupted()静态方法的目标对象: 它的目标对象为“当前线程” ，而不管是调用的


多线程：

-- 进程：是程序的执行过程，是动态的，持有资源（内存，文件）和线程，双击运行一个程序既是一个进程

-- 线程：是系统中最小的执行单元，同一个进程有多个线程，多个线程共享进程的资源

线程的交互方式：

   --互斥：竞争，关键数据在同一时间只能有一个线程访问
   
   --同步：协作，线程间的一种通信控制，一个线程完成了某事后唤醒其他因某些资源不足而等待的线程
 
 
 
--线程的状态：

New : 已创建还没启动的新线程，未调用start()方法

Runnable: 可运行状态创建了线程对象后，调用了线程的start()方法（注意：此时线程只是进入了线程队列，等待获取CPU服务，具备了运行的条件，
          但并不一定已经开始运行了），只要调用了start()方法 都是在runnable状态。

Blocked：当一个线程在进入 被synchronized修饰的同步代码块，且当前锁(monitor)已经被其他线程拿走时 (仅限synchronized修饰)

Waiting: 当一个线程调用Object.wait() , Thread.join() ,LockSupport.part() 的方法时进入等待状态。

TimedWaiting: 当一个线程调用Thread.sleep(time),Object.wait(time),Thread.join(time),LockSupport.partUntil(time) 的方法时进入等待状态。

Terminated : 已终止状态。(1，正常运行结束 2，出现未捕获的异常)





线程的生命周期：

创建：创建一个Thread对象

就绪：创建了线程对象后，调用了线程的start()方法（注意：此时线程只是进入了线程队列，等待获取CPU服务，具备了运行的条件，但并不一定已经开始运行了）

运行：处于就绪状态的线程，一旦获取了CPU资源，便进入到运行状态，开始执行run()方法里面的逻辑

终止：线程的run()方法执行完毕，或者线程调用了stop()方法，线程便进入了终止状态。

阻塞：一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU，暂停自己的执行，便进入了阻塞状态。如调用sleep()、join()、wait()方法
 
 
 
 
 
 Race Condition <争用条件>
--当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupted）,这种现象称为争用条件。
   
   1,多线程之间的互斥（加锁实现）：同一时间，只能有一个线程访问临界区（防止线程之间争用条件造成的“能量损失”）[对该临界资源进行加锁，表示现在只能由该线程进行访问]
    
	    线程之间的互斥：通过加锁实现：线程访问临界区的代码放在一个代码块中，加锁实现

   2,多线程之间的同步（线程的等待和唤醒：wait()+notifyAll()）：通信机制；一个线程完成，以某种方式通知其他线程可以访问临界区
        A
		线程之间的同步：通过wait（）+notify（）的通信机制来实现
		
		线程同步的实现有wait()（会释放所资源和释放锁，然后进入锁对象上的wait set）,notify()（会唤醒所对象的wait set中的一个线程）,notifyAll()
		（会唤醒所对象的wait set中的所有线程）这几个方法来实现,这几个方法都是属于object

   lockObj.notifyAll()；唤醒所有等待资源的线程。等待池的对象是不会竞争锁的，当notifyAll后，等待池中的线程会被唤醒进入到该线程的锁池中重新竞争对象锁，
    重新获得锁后的对象会从wait后继续执行代码，其他对象会被阻塞，而不是wait。被阻塞的对象会等待下一次被唤醒（notify、notifyAll）。另外，notify不是线程安全的，notifyAll才是。

-- notify()与notifyAll()  区别：

    锁池：当一个线程进入synchronize代码块且拿到当前锁，其他进入synchronized代码块当线程则进入锁池。 (竞争锁)
    等待池：当线程使用wait();释放锁后，会进入等待区 不再竞争此锁。 (不竞争锁)

    notify: 随机在等待区中选取一个线程进入锁池；

    notifyAll: 将所有等待区当线程放入锁池；


   
   
--线程中的方法
   
Thread.currentThread().getName();获取当前线程的名称。

volatile;可见性，java的关键字(保证了线程可以正确的读取其他线程写入的值)

Thread.yield();让出当前线程的执行权限，随机选择线程执行。但是线程调度器可以忽略。

Thread.sleep();线程休眠 /不释放任何锁
               会使线程进入TIME_WAITING 状态，不会占用CPU资源，但是不会释放锁。直到休眠结束，或者休眠期间被打断，会抛出异常并清除中断状态。

Thread.join();优先执行该线程，其他线程都暂停。使同级其他线程停下来，等待调用join方法的对象完成线程后，再进行其他线程

thread.isAlive()可以知道线程是否在运行，所以while死循环也可以做到”等待线程执行完，再执行下一行的代码的效果






--interrupt() 中止线程
 
  当一个线程调用因为调用sleep(),join(),方法被阻塞时。一旦其他线程调用 interrupt() 会使的中断状态被清除，并且抛出interruptedException
  
  --中断状态值：isInterrupted （默认为false，如果被阻塞则变为true）
  

  
  
  
  
 --并发编程的3个基本概念  
   
   -- 原子性： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
   
   -- 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
   
   -- 有序性：即程序执行的顺序按照代码的先后顺序执行。
   
   
   
   
   
 --守护线程：
  
 1、用户线程——运行在前台，执行具体的任务

        程序的主线程、连接网络的子线程等都是用户线程

2、守护线程——运行在后台，为其它线程服务

        特点：当所有的用户线程都结束运行，守护线程会随JVM一起结束工作

        应用：数据库连接池中的检测线程

                   JVM虚拟机启动后的监测线程 

        最常见的守护线程：垃圾回收线程

3、可以通过调用Thread类的setDaemon(true)方法，设置当前线程为守护线程。注意：

a）该方法必须在start()方法之前调用，否则会抛出IllegalThreadStateException异常。

b）在守护线程中产生的新线程也是守护线程。

c）不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑。


--为什么wait() 需要在同步代码块中，而sleep()不需要
为了使得通讯变得可靠，防止死锁或者永久等待
如果wait()不放在代码块中，可能会发生在wait() 之前被notify() 他会永久等待
sleep只是针对自己，对其他线程影响不大

--Thread 和 Object
wait() 和 notify() 为锁级别的操作，而锁是针对每一个对象的
如果某个线程持有多个锁，相互配合。如果定义在Thread中就无法实现这种逻辑了


--如何实现处理线程的返回值
 1，主线程等待法 ： 主线程循环等待直到目标线程返回值为止  --CycleWait();
 2, 使用Thread中的join()方法来阻塞当前线程，等待子线程运行完。--CycleWait();
 3，使用Callable接口实现，通过Future Task 或者 线程池获取。

--如何给线程传参
 1，构造方法传参；
 2，通过变量或者方法传递；
 3，回调函数传递；


-- CAS (Compare and Swap) 属于乐观锁
  > 支持原子更新操作，适用于计数器，序列发生器等场景
  > 属于乐观锁机制，
  > CAS操作失败时由开发者决定是继续尝试，还是执行别的操作

 思想：
   三个操作数 --内存位置(V),预期原值(A)和新值(B)
            将V与A比较，如果相等，则B替换V 否则不做操作
