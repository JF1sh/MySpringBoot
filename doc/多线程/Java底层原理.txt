1: java代码到CPU指令的过程
    1-1): 首先编写的是java代码 是 *.java
          在编译(接收到javac命令后) 从刚才的 *.java 文件会变成一个新的java字节码文件(*.class)
          JVM会执行刚才生成的字节码文件(*.class),通过类加载器(Class Loader)并把字节码文件转化为 机器指令
          机器指令可以直接在CPU上执行，也是最终的程序执行

      JVM实现会带来不同的 "翻译"，不同的平台 和 机器指令 是千差万别的，无法保证并发安全的效果一致。所以引入jmm


-----------------------------------------------------------------------------------------------------------------

JVM 的内存结构 (java Virtual Machine)：
                和java虚拟机的 运行时区域 有关。
                (java代码是运行在虚拟机上的，虚拟机会把运行过程中的内存分为不同的区域，方便虚拟机管理，
                每个区域有不同的作用)

            所以线程共享区域：
                 1) 堆： 整个运行区域最大的一个部分。存放new等相关指令创建的实例，数组，运行时动态分配
                 2) 方法区：存放已经加载的static静态变量，类信息，常量信息，永久引用 (代码片段)
            各个线程私有区域：
                 3) java栈(虚拟机栈): 保存基本数据类型，对象的引用(普通引用),局部变量
                 4) 本地方法栈 : 保存本地方法相关的(指的是native方法)
                 5) 程序计数器 : 保存当前线程所执行到的字节码行号数(上下文切换时会保存数据)
                                还包括下一条需要执行的指令，分支循环 异常处理。


                 <项目启动时，会先加载class文件，类的信息和代码片段以及静态变量被存放在方法区。当执行类中方法时，先执行压栈操作，
                 为执行的方法在栈中开辟空间，局部变量存放在栈中，在创建对象时会在堆中开辟一个空间，类中的实例变量被初始化。栈中
                 对象的引用存放实例对象的地址并指向堆中开辟的空间。>

------------------------------------------------------------------------------------------------------------------



java对象模型: 和java在虚拟机中的表现形式有关 (表示java对象的存储模型)
              在方法区，创建类信息，然后每个实例都会被放在堆中。 如果某个对象被方法调用，就会在栈中把引用保存下来

              过程为：jvm会给这个类创建一个instanceKlass,保存在方法区，用于在jvm层表示该java类
                     当用new创建一个对象时，jvm会创建一个instanceOopDesc对象，会在栈中赋值，这个对象包括对象头和实例数据
                     存放在堆中
                     当某个方法调用该对象时，会在栈中保存 引用

-----------------------------------------------------------------------------------------------------------------



java内存模型(java Memory Model): 和java的并发编程有关
               1: 是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用规范，开发多线程程序
               2: synchronized volatile lock 等原理 就是 jmm。内存栅栏：工作内存和主内存之间的copy和同步

               JMM原理：
               ----------------------------------------------------------------------
                  1-1):重排序:
                        代码指令并不是严格按照代码语句顺序执行的。(上下无依赖关系)
                        好处：提高了处理速度。(进行了指令的优化)

                        3中情况：
                          编译器优化 : JVM JIT 编译器优化
                          CPU指令重排: 就算编译器发生重排，CPU也会发生重排序
                          内存的"重排序": 内存中有缓存的存在，JMM中表现为 主存和本地内存，当线程A修改了本地的变量的值，
                                         而没有写入主存，而线程B却从本地内存拿到了之前的值。

               ----------------------------------------------------------------------
                 1-2):可见性:
                       CPU有多级缓存，导致读取的数据过期
                       --高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间多了Cache层
                       --线程之间的对共享变量的可见性问题不是因为多核引起的，而是有多缓存引起的


                       --所有的共享变量存在于主内存中，每个线程有自己的本地内存，
                         而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。


                         happens-before：原则： 动作A发生在动作B之前，B保证能看见A


               ----------------------------------------------------------------------

                  1-3):原子性:
                       一系列的操作，要么全部成功也么全部失败

                       --java中具有原子操作：
                          1： 除long和double之外的基本类型操作(int,byte,boolean,short,char,float)的赋值
                          2： 所有引用reference的赋值操作。
                          3： java.  .Atomic.*包中所有类的原子操作

               ----------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------
volatile 关键字: 是一种同步机制，比synchronized和lock相关类更加轻量，因为不会发生上下文切换等大量的开销
                 它只是把本地内存的值刷到主内存中

         --机制: 1)禁止重排序: 解决单例双重锁乱序问题。

                 2)可见性: 读取一个volatile变量之前，会使得本地缓存失效，必须从主存读取新值。

         --适用场景:
              1): boolean flag.(直接赋值，而非取决于之前状态) 如果一个共享变量自始至终只是被各个线程直接赋值，
                                而没有其他操作， 那么它代替synchronized或者原子变量，因为赋值本身就是原子性，
                                而volatile保证了可见性，所以足以保证线程安全。

              2):作为刷新之前的触发器: 两个线程对一个被volatile修饰的变量进行操作，一个取值，一个赋值，根据
                                happens-before 原则，使得取值的线程会看见赋值线程所作的任何动作。
-----------------------------------------------------------------------------------------------------------------

volatile总结：
   1: volatile修饰符的适用场景：一个属性被多个线程共享，其中一个线程修改了此属性，其他线程会立即拿到被修改后的值;或者作为
      触发器使用，实现轻量级同步。

   2: volatile的读写是无锁的，它不能代替synchronized,因为它没有提供原子性和互斥性,因为无锁，不要花费时间获取释放锁，成本低

   3: volatile只能作用于属性，我们用volatile修饰属性，这样compilers(编译器)就不会对这个属性做指令重排序

   4: volatile提供了可见性，任何一个线程对其做了修改将立马对别的线程可见.volatile属性不会线程缓存，始终从主存读取

   5: volatile提供了happens-before保证，对volatile变量v的写入 happens-before 所有其他线程后续对v的操作

   6: volatile可以使得long 和 double 的赋值是原子的。

-----------------------------------------------------------------------------------------------------------------

单例模式的作用：
       节省内存，保证结果正确，方便管理

     --使用场景：
         1: 无状态的工具类：比如日志管理工具，不管是在哪里使用，我们需要的只是它帮我们记录日志信息，除此之外，并不需要在它的实
            例上存储任何状态，这时候我们就只需要一个实例对象就好了。

         2: 全局信息类：比如我们在一个类上记录网站的访问次数，我们不希望有些被记录在对象A上，有些被记录在对象B上，这时候我们就
            让这个类成为单例