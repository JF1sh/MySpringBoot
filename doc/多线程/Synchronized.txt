Synchronized

 作用：能够保证在同一时刻最多只有一个线程执行该段代码，已达到保证并发安全的效果。
 
 
 
 
--用法：
   
    -- 对象锁: 1)代码块形式：手动锁定对象 (this 可以使用新建的对象来完成，)
	
	                        synchronized(this){
							   逻辑代码
							}

               2)方法锁形式：synchronized修饰普通方法，锁对象默认为this。在方法中加上 Synchronized关键字
			   
	
	--  类锁： 1) synchronized修饰静态方法:(一个类可以有多个实现类，但是只能有一个class对象。如果由多个实现类开起的线程，
	                                         同时去获取一个对象锁。所开启的线程都可以获取到，而使用类锁则只有一个可以获取到)。
											 
			 
  			  2) synchronized代码块(*.class)
	                        synchronized(*.class){
							   逻辑代码
							}
							
--方法抛出异常后，会释放锁。（自定义的lock不会自动释放）


-- 性质：  可重入：一旦一个线程获取到当前锁，可以一直用下去直到自己释放，别人才能获得。（当两个方法被一个锁修饰，当前线程可以执行完两个方法后再释放锁）

           不可中断： 一旦一把锁被别人获取，除非他释放不然我只能一直等待
		   



--加锁原理
   每一个类的实例对应着一把锁，而每一个synchronized方法都必须首先获得调用该方法的类的实例的锁，才能执行。否则线程就会阻塞，
   而方法一旦执行，就会独占这把锁，直到该方法返回，或者抛出异常，才将锁释放。释放之后，其他被阻塞的线程才能获得这把锁，重新进入可执行的状
   态。
		   
		   
--synchronized关键字的缺陷

效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程

不够灵活（读写锁更灵活）：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的

无法知道是否成功获得到锁


--synchronized 使用的注意点：

       1：锁对象不能为空。作用域不易过大。避免死锁

          1）锁对象不能为空：必须是一个实例对象，被new过，或者使用其他方法创建好，而不是空对象。这是因为，锁的信息保存在对象头中，对象都没有，更没有对象头，所以这个锁不能工作

          2）作用域不宜过大：将尽可能多的代码使用synchronized包裹，会降低出并发问题的可能性，因为大部分线程都是串行工作，没有达到多线程编程的目的，影响程序执行的效率

          3）避免死锁

       2、如何选择Lock和synchronized关键字

           1）如果可以的话，两者都不要使用，使用JUC(java.util.concurrent包中的Atomic类、countDown等类)中的各种类

           2）如果synchronized关键字，在程序中适用，那么就优先使用（可以减少所编写的代码）

           3）如果特别需要使用到Lock灵活的加解锁机制独有的特性时，就是用Lock